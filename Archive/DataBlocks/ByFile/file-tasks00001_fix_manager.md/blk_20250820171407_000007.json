{
  "block_id": "blk_20250820171407_000007",
  "parent_sha256": "3ca43bcd334ac70e0d5b844823ed9d0e1280e9c4268e193850fc7dda62f4a98a",
  "src_file": "file-tasks00001_fix_manager.md",
  "seq": 1,
  "total_seqs": 1,
  "encoding": "utf-8",
  "lang": "ru",
  "status": "ok",
  "size_bytes": 4355,
  "hash_sha256": "3ca43bcd334ac70e0d5b844823ed9d0e1280e9c4268e193850fc7dda62f4a98a",
  "tags": [],
  "text": "┌─ <file> tasks/00001_fix_manager.md\r\n│\r\n│ # 018 — Fix Manager  (баг‑очередь + жизненный цикл)\r\n│\r\n│ ## Overview\r\n│ Нужен симметричный модуль к TestManager: он принимает сообщения о\r\n│ багах, хранит их, меняет статус, шлёт события в EventManager и\r\n│ даёт API для Dashboard.  Минимальное постоянство — JSON‑файл,\r\n│ дальше можно мигрировать в БД.\r\n│\r\n│ ## Goals / Acceptance\r\n│ - Модуль `lam.fix_manager.FixManager` с CRUD‑методами и JSON‑storage.  \r\n│ - Enum `FixStatus {NEW, IN_WORK, DONE, REJECTED}`.  \r\n│ - FastAPI‑роуты:  \r\n│     * **GET** `/fix` ?status=NEW  \r\n│     * **POST** `/fix` {title, description, tags?}  \r\n│     * **PATCH** `/fix/{id}` {status, owner?}  \r\n│ - Каждое действие порождает `Event(kind=\"FIX\", …)` → попадает в\r\n│   логи Conscious‑Loop.  \r\n│ - Тесты `tests/test_fix_manager.py` — покрытие ≥ 90 %.  \r\n│ - CLI‑обёртка:  \r\n│     ```\r\n│     lam fix add   --title \"Crash\" --desc \"stacktrace...\"\r\n│     lam fix list  --status NEW\r\n│     lam fix set   <id> --status IN_WORK --owner Kirill\r\n│     ```\r\n│ - Dashboard (вкладка “Fixes”) показывает таблицу с цветовой\r\n│   подсветкой статуса.\r\n│\r\n│ ## Prompts\r\n│\r\n│ ### LAM prompt\r\n│ «Держи внутреннюю приоритетную политику:  \r\n│   • Если `tags` содержит `\"critical\"`, то EventManager создаёт\r\n│     BLOCK‑event и само‑планировщик ставит Intent‑REST (паузу) до\r\n│     устранения.  \r\n│   • При статусе `DONE`, если прошло < 24 h, LAM генерирует\r\n│     follow‑up: «Проверить регрессию?»»\r\n│\r\n│ ### User prompt (Kyrylo → LAM)\r\n│ «/fix add title:\"<краткая суть>\"  \r\n│    description:\"<как воспроизвести + ожидание>\"  \r\n│    tags:[ui,critical]»  \r\n│ LAM отвечает ID и предполагаемым приоритетом.\r\n│\r\n│ ### Codex prompt  (для автогенератора кода)\r\n│ 1. Создать `lam/fix_manager.py` со скелетом:  \r\n│    ```python\r\n│    class FixManager:\r\n│        def add(self, title:str, description:str, tags:List[str]|None=None)->FixItem: ...\r\n│        def assign(self, id:str, owner:str)->None: ...\r\n│        def update_status(self, id:str, status:FixStatus)->None: ...\r\n│        def list(self, status:FixStatus|None=None)->List[FixItem]: ...\r\n│    ```  \r\n│ 2. JSON‑storage (`memory/fixes.json`) автосоздаётся.  \r\n│ 3. FastAPI router в `lam/web/router_fixes.py`, тег «fix».  \r\n│ 4. CLI‑команды через `typer` sub‑app `lam fix …`.  \r\n│ 5. Тесты: edge‑cases (неизвестный id, двойное назначение).  \r\n│\r\n│ ### Operator prompt  (DevOps/CI)\r\n│ - Добавь в README раздел «Bug‑flow».  \r\n│ - Проверь:  \r\n│     ```bash\r\n│     lam fix add --title \"REST loop freeze\" --desc \"steps…\" --tags critical\r\n│     lam fix list\r\n│     ```  \r\n│ - В Dashboard вкладка «Fixes»: статус NEW → клик «Assign me» → id\r\n│   окрашивается жёлтым (IN_WORK).  \r\n│ - CI job `fix-manager-test` в matrix linux/macos.\r\n│\r\n│ ### Agent prompt  (TestManager / CI‑бот)\r\n│ - На каждый Pull Request ищи текст “fixes #ID” → пингуй\r\n│   `/fix/{ID}` status=IN_WORK.  \r\n│ - Если все упомянутые фиксы перешли в `DONE`, комментируй PR:\r\n│   «All referenced fixes resolved — merge allowed».  \r\n│ - Еженощно дергай `/fix?status=NEW` и пость summary в Slack‑канал.\r\n│\r\n│ ## File map\r\n│ ```\r\n│ lam/\r\n│   fix_manager.py\r\n│   web/router_fixes.py\r\n│ tasks/018_fix_manager.md\r\n│ tests/test_fix_manager.py\r\n│ memory/fixes.json           # авто‑создаётся\r\n│ ```\r\n│\r\n│ ∴\r\n└─\r\n"
}