{
  "block_id": "blk_20250820171407_000011",
  "parent_sha256": "9dccf36eef722a3186e97c4f3eb499d3b0e9777e41c942e444cc9bbda6b16e53",
  "src_file": "file-tasks011_performance_profiling.md",
  "seq": 1,
  "total_seqs": 1,
  "encoding": "utf-8",
  "lang": "ru",
  "status": "ok",
  "size_bytes": 1491,
  "hash_sha256": "9dccf36eef722a3186e97c4f3eb499d3b0e9777e41c942e444cc9bbda6b16e53",
  "tags": [],
  "text": "┌─ <file> tasks/011_performance_profiling.md\r\n│\r\n│ # 011 — Тест на выносливость\r\n│\r\n│ ## Overview\r\n│ Гоним движок с 10 000 воспоминаний, ищем тормоза и\r\n│ утечки памяти.  Цель — держать loop < 200 мс и RAM < 300 МБ.\r\n│\r\n│ ## Goals / Acceptance\r\n│ - `scripts/bench.py` генерит синтетические данные,\r\n│   крутит 1 000 циклов, печатает latency/ram stats.\r\n│ - `py-spy` flamegraph (`benchmarks/engine.svg`).\r\n│ - CI job `bench-compare`: медианная задержка не > +15 % от базовой.\r\n│\r\n│ ## LAM prompt\r\n│ «Определи ключевые метрики устойчивости, которые\r\n│   важнее всего для живого цикла (CPU, IO, GC?)».\r\n│\r\n│ ## Codex prompt\r\n│ 1. Сгенерировать 10k JSON воспоминаний (rand text, ts).\r\n│ 2. Использовать `tracemalloc` для RAM, `time.perf_counter` для latency.\r\n│ 3. Вывод CSV → график matplotlib (сохр. в `benchmarks/latency.png`).\r\n│ 4. Скрипт `bench_baseline.json` хранится в репо,\r\n│    compare = fail if regressed.\r\n│\r\n│ ## Operator prompt\r\n│ - Запусти `python scripts/bench.py --baseline-save` один раз.\r\n│ - На PR увидишь комментарий-отчёт (artifact download).\r\n│\r\n│ ∴\r\n└─\r\n"
}